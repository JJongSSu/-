<코드 작성 시 확인사항>
1. 정확성 => 정답

2. 시간복잡도 => 명령어 실행 횟수 = 실행시간
	*가  /보다 시간복잡도가 좋음
	수식화
	size가 적을 때는 for문보다 직접 선언해주는게 좋다
	연산자 사용(&, |, !=, ~, ^, +, -, *, /, %, //, >>, <<) → '<<는 같은 값을 2번 곱한 값, >>는 같은 값을 2번 나눈 값으로 활용할 수 있음' : 시트프 연산자가 속도가 빠름
	논리 연산자(&&, ||)
	짝수/홀수 판별 : (int type일 때) if(x<<31 & 1) 홀수, if(x<<31 & 0) 짝수 
	함수를 따로 빼면 시간 오래걸림, main에서 대부분 해결하는게 좋음

3. 공간복잡도 => RAM 사용량 = 메모리 사용량, 변수사용량
	배열(자바), 리스트(파이썬) 사용

4. 소스 간결성

5. 최적화 => 수정필요x

- 1부터 n까지의 합(시그마 활용) : 수학 공식을 알고는 있어야 함
int n = 0;
double sum = 0.0;
sum = n(n+1)* 0.5;


CPU					RAM
ALU(연산처리장치)			Stack : 함수, 지역변수(def 안에 선언된 변수) -> 함수 내에서만 유효, 임시로 사용하는 공간, Stack공간에 data를 쌓아서 memory를 잡아먹는걸 줄여줘야 됨
					Heap(동적 메모리 공간) : new 객체 -> 시스템 종료시까지 유효, 연속적인 공간(배열, 리스트)이면 접근성이 좋아지기 때문에 속도 빠름
					Shared Data(Static memory) : 전역변수(함수 외부에서 선언된 변수, (파이썬) global변수) -> 프로그램 종료시까지 유효, 다른 함수들이 공유 사용 가능
					Code

-> Heap, Shared Data 공간을 많이 활용하는게 프로그래밍 잘하는 방법

DB recode : type별 구분 가능
같은 type -> 배열, 리스트 접근
다른 type -> 개별 접근 or 같은 type별로 묶어놓고 사용

DB
	Varchar : 지정범위 내 개수 유동적
	Char : 개수 고정


Stack에서 average함수 사라지고 나면
Heap영역에 남아있는 점수들은 그대로 유지되어 있음??

double average(int[] score){
		double avg = 0;
		for(int i=0; i<score.length; i++){
			avg += score[i];
		}
		avg = avg/score.length;
		return avg;
	}
에서 int=sum하는 방법과 avg에 바로 더해주고 다시 나눠주는 방법과 어떤게 더 괜찮은 방법??




